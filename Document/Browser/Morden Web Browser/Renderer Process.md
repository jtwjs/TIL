## 렌더러 프로세스(Renderer Process)의 내부 동작

- 렌더러 프로세스는 여러 측면에서 웹 페이지의 성능에 영향을 끼친다

### 렌더러 프로세스는 웹 콘텐츠를 처리한다

> 탭 내부에서 발생하는 모든 작업을 담당한다.

- 렌더러 프로세스의 `메인 스레드`가 브라우저로 전송된 대부분의 코드를 처리한다.
  - 간혹 웹 워커나 서비스 워커를 사용하는 경우에는 워커 스레드가 JS코드의 일부를 처리한다.
- 웹 페이지를 효율적이고 부드럽게 렌더링하기 위해 별도의 `컴포지터 스레드`와 `래스터 스레드`가 렌더러 프로세스에서 실행된다.

- 렌더러 프로세스의 주요 역할은 **HTML과 CSS, JS를 사용자와 상호작용을 할 수 있는 웹페이지로 변환**하는 것이다.

![렌더러 프로세스](https://user-images.githubusercontent.com/60641307/97270643-d8594700-1872-11eb-8b2d-2eb453fa8129.png)

### 파싱(Parsing)

#### DOM 구축

> 페이지를 이동하는 내비게이션 실행 메시지를 렌더러 프로세스가 받고 HTML 데이터를 수신하기 시작하면 렌더러 프로세스의 메인 스레드는 문자열(HTML)을 파싱해서 DOM(document object model)으로 변환하기 시작한다.

- DOM은 브라우저가 내부적으로 웹페이지를 표현하는 방법일 뿐만 아니라 웹 개발자가 JavaScript를 통해 상호작용을 할수있는 데이터 구조이자 API이다.

#### 하위 리소스(subresource) 로딩

> 웹사이트는 일반적으로 이미지, CSS, JS와 같은 외부 리소스를 사용한다.

- 이러한 파일은 네트워크나 캐시에서 로딩해야 한다.
- DOM을 구축하기 위해 파싱하는 동안 이런 리소스를 만날때마다 메인스레드가 하나하나 요청할수도 있을것이다.
  - 하지만 속도를 높이기 위해 `프리로드(Preload)스캐너`가 동시에 실행된다.
- HTML문서에 `<img>` 또는 `<link>`와 같은 태그가 있으면 프리로드 스캐너는 HTML 파서가 생성한 토큰을 확인하고 브라우저 프로세스의 네트워크 스레드에 요청을 보낸다.

#### 자바스크립트가 파싱을 막을수 있다.

> `<script>`태그를 만나면 HTML 파서는 HTML 문서의 파싱을 일시 중지한 다음 JS코드를 로딩하고 파싱해 실행해야 한다.

- JS는 DOM구조 전체를 바꿀수 있는 `document.write()`메서드와 같은 것을 사용해 문서의 모양을 변경할수 있기 떄문이다.
- HTML파싱을 재개하기 전에 HTML파서는 JS의 실행이 끝나기를 기다려야 한다.

### 리소스를 어떻게 로딩하길 원하는지 브라우저에 힌트를 주는방법

> 웹개발자가 브라우저에 리소스 로딩에 대한 힌트를 보내는 방법에는 여러가지가 있다.

- JS에서 document.write() 메서드를 사용하지 않는다면 `<script>`태그에 `async속성`이나 `defer속성`을 추가할수 있다.

  - 이 속성이 있으면 브라우저가 JS코드를 비동기적으로 로딩하고 실행하면서 HTML 파싱을 막지 않는다.

- `JS모듈`을 사용할수도 있다.
- `<link rel="preload">`는 현재 내비게이션을 실행하기 위해 리소스가 반드시 필요하다는것을 브라우저에 알려서 리소스를 가능한한 빨리 다운로드하려는 경우 사용가능

### 스타일 계산

> 메인 스레드는 CSS를 파싱하고 각 DOM 노드에 해당되는 계산된 스타일을 확정한다.

- 계산된 스타일은 CSS선택자(selector)로 구분되는 요소에 적용될 스타일에 관한 정보이다.

### 레이아웃

> 레이아웃은 요소의 기하학적 속성(geometry)를 찾는 과정이다.
> <br>메인 스레드는 DOM과 계산된 스타일을 훑어가며 레이아웃 트리를 만든다.

- 레이아웃 트리는 x, y 좌표, 박스 영역의 크기와 같은 정보를 가지고 있다.
- 레이아웃 트리는 DOM 트리와 비슷한 구조일 수 있지만 웹페이지에 보이는 요소에 관련된 정보만 가지고 있다.
- `display: none`속성이 적용된 요소는 레이아웃 트리에 포함되지 않는다.
- `p::before`속성과 같은 의사클래스(pseudo class)의 콘텐츠는 DOM에는 포함되지 않지만 레이아웃 트리에는 포함된다.

- 레이아웃 트리와 페인트 트리사이에 한가지 작업이 더있다.
  - 레이아웃 트리를 순회하면서 속성 트리(property tree)를 만드는 작업이다.
  - 속성트리는 `clip,transform,opacity`등의 속성 정보만 가진 트리이다.

### 페인트

> 페인트 단계에서 메인스레드는 페인트 기록(paint record)을 생성하기 위해 레이아웃 트리를 순회한다.

- 페인트 기록은 '배경'먼저, 다음은 텍스트, 그리고 직사각형과 같이 페인팅 과정을 기록한 것

### 렌더링 파이프라인을 갱신하는 데는 많은 비용이 든다.

![DOM tree](https://user-images.githubusercontent.com/60641307/97278426-207d6700-187d-11eb-942f-359d2a4a4ad3.gif)

> 렌더링 파이프라인에서 파악해야할 가장 중요한 점은 각 단계에서 이전 작업의 결과가 새 데이터를 만드는데 사용이 된다는 것

- 예를 들어 레이아웃 트리에서 변경이 생겨 문서의 일부가 영향을 받으면 페인팅 순서도 새로 생성해야 한다.

### 합성

> 브라우저는 문서의 구조와 각 요소의 스타일, 요소의 기하학적 속성, 페인팅 순서들의 정보를 화면의 픽셀로 변환하는 작업을 래스터화(rasterizing)라고 한다.

- 최신 브라우저는 합성(compositing)이라는 보다 정교한 과정을 거친다.

#### 합성이란 무엇인가

> 웹 페이지의 각 부분을 레이어로 분리해 별도로 래스터화하고 컴포지터 스레드(compositor thread)라고 하는 별도의 스레드에서 웹페이지로 합성하는 기술이다.

- Chome 개발자 도구의 `Layers 패널`에서 웹사이트가 어떻게 레이어로 나뉘어 있는지 볼수 있다.

#### 여러 레이러로 나누기

> 어떤 요소가 어떤 레이어에 있어야 하는지 확인하기 위해 메인 스레드는 레이아웃 트리를 순회하며 레이어 트리를 만든다.

- 모든 요소에 레이어를 할당하면 좋을것 같지만 수많은 레이어를 합성하는 작업은 웹 페이지의 작은 부분을 매 프레임마다 새로 레스터화하는 작업보다 더오래 걸릴수 있다.
- 레이어가 많으면 합성 비용이 높을뿐만 아니라 레이어를 메모리에 가지고 있어야 하는 부담도 있다.

#### 메인 스레드 이후 래스터화와 합성

> 레이어 트리가 생성되고 페인트 순서가 결정되면 메인 스레드가 해당 정보를 컴포지터 스레드에 넘긴다.
> <br>그러면 컴포지터 스레드는 각 레이어를 래스터화 한다.

- 컴포지터 스레드는 레이어를 타일형태로 나눠 각 타일을 래스터 스레드로 보낸다.
- 래스터 스레드는 각 타일을 래스터화해 GPU 메모리에 저장한다.

- 컴포지터 스레드 안에도 레이어트리가 여러개 있다.

  - 메인스레드가 넘긴 레이어트리는 컴포지터 스레드의 펜딩트리로 복사된다.
  - `펜딩 트리`는 아직 화면에 그려지지 않았지만 최신 프레임이라고 할 수 있다.
  - 현재 화면에 그려지고 있는 이전 프레임은 `액티브 트리`로 그린 프레임이다.
  - 최신정보로 화면을 갱신할떄는 펜딩트리와 액티브 트리를 `교체(swap)`한다.

- 타일이 래스터화되면 컴포지터 스레드는 `합성 프레임`을 생성하기 위해 타일의 정보를 모은다.
  - 이 타일의 정보를 `드로 쿼드(draw quads)`라 부른다.
- 이후에 합성 프레임이 IPC를 통해 브라우저 프로세스로 전송된다.

- 합성의 이점은 메인스레드와 별개로 작동할수 있다는 것
  - 컴포지터 스레드는 JS실행이나 스타일 계산을 기다리지 않아도 된다.
