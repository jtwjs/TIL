## Navigation

> (사이트 간의) 이동

- 사용자가 사이트를 요청하고 브라우저가 페이지 렌더링을 준비하는 과정

### Navigation 단계

#### 1단계: 입력처리

> 사용자가 주소 표시줄에 타이핑을 시작하면 UI 스레드는 먼저 입력되는 내용이 검색어(search query)인지 URL인지 확인한다.

- Chrome에서 주소 표시줄은 검색창이기도 하다.
- UI 스레드는 입력되는 내용을 파싱해서 검색 엔진으로 이동할지 요청한 사이트로 이동할지 결정해야 한다.

#### 2단계: 내비게이션 시작

> 사용자가 Enter 키를 누르면 사이트의 콘텐츠를 가져오기 위해 UI 스레드가 네트워크 호출을 시작한다.

- 로딩 스피너가 탭의 모서리에 표시되고, 네트워크 스레드는 요청에 대한 DNS Lookup 및 TLS 연결 설정과 같은 적절한 프로토콜 을 거쳐 요청을 처리한다.

- 이때 네트워크 스레드가 HTTP 301과 같은 서버 리디렉션 헤더를 수신할수도 있다.
  - 그런 경우에는 네트워크 스레드가 UI스레드와 통신해 서버가 리디렉션을 요청했다는 것을 알린다.
  - 그런 다음 새로운 URL요청이 시작된다.

#### 3단계: 응답 읽기

> 응답 본문인 페이로드가 들어오기 시작하면 네트워크 스레드는 필요에 따라 스트림의 처음 몇바이트를 확인한다.

- 페이로드가 어떤 형식의 데이터인지는 응답 헤더의 Content-Type 헤더가 알려주지만 정보가 없거나 잘못된 정보가 있을 수 있다.
  - 그래서 이때 `MIME 스니핑`을 실행해 데이터의 실제 형식을 알아낸다.
- 응답이 HTML 파일이라면 데이터를 렌더러 프로세스에 전달하는 단계로 넘어간다.
  - 응답이 ZIP 형식파일이나 다른 형식의 파일이라면 다운로드 요청이므로 다운로드 매니저에 데이터를 전달하는 단계로 넘어가야한다.
  - (렌더러 프로세스가 다룰 수 있는 데이터 형식일때 & 렌더러 프로세스가 다룰 수 없는 데이터 형식일 때로 구분)
- 또한 `Safe Browsing`의 검사가 실행되는 단계이다.
  - 도메인과 응답 데이터가 악성사이트로 알려진 사이트와 일치하는것 같다면 네트워크 스레드는 경고 페이지를 표시하라고 알림
  - `CORB(Cross-Origin Read Blocking)`기능이 서로 다른 사이트(cross-site)의 민감한 데이터가 렌더러 프로세스에서 실행되지 않게 검사한다.

#### 4단계: 렌더러 프로세스 찾기

> 모든 검사가 끝나고 브라우저가 요청된 사이트로 이동해야 한다고 네트워크 스레드가 확신하게 되면 네트워크 스레드는 UI 스레드에 데이터가 준비되었음을 알린다.
> <br>그러면 UI 스레드는 웹 페이지의 렌더링을 수행할 렌더러 프로세스를 찾는다.

- 네트워크 요청이 응답을 받기까지 수백 밀리초가 걸릴 수 있기 때문에 이 과정을 더빨리 진행하기 위한 최적화가 적용되어 있다.
- 2단계에서 UI스레드가 네트워크 스레드로 URL 요청을 보낼때 UI스레드는 이미 어느사이트로 이동할지 알고 있다.
  - UI 스레드는 렌더러 프로세스를 먼저 찾거나 네트워크 요청과 동시에 렌더러 프로세스를 시작한다.

#### 5단계: 내비게이션 실행

> 이제 데이터와 렌더러 프로세스가 준비되었으므로 내비게이션을 실행하도록 브라우저 프로세스에서 렌더러 프로세스로 IPC 메시지를 전송한다.

- 또한 렌더러 프로세스가 HTML 데이터를 계속 수신할수 있도록 브라우저 프로세스는 데이터 스트림을 전달한다.
- 렌더러 프로세스에서 내비게이션이 실행되었다는 것을 브라우저 프로세스가 확인하고 나면 내비게이션이 완료되고 문서 로딩단계가 시작된다.

- 이 시점에 주소 표시줄이 업데이트되고 보안 표시와 사이트 설정 UI도 새 페이지의 사이트 정보를 반영해 갱신된다.
- 탭에 대한 세션 기록이 업데이트되어 뒤로 가기 버튼과 앞으로 가기 버튼도 방금 이동한 사이트를 반영해 작동한다.
- 탭이나 창을 닫은 이후 탭과 세션을 복원할수 있게 세션기록이 디스크 드라이브에 저장된다.

#### 추가단계: 초기 로드 완료

> 내비에기션이 실행되면 렌더러 프로세스는 계속 리소스를 로딩하고 페이지를 렌더링한다.

- 렌더러 프로세스가 렌더링을 끝내면 브라우저 프로세스로 IPC 메시지를 보낸다
  - 그러면 UI스레드는 탭에서 로딩 스피너의 작동을 중지한다.

### 다른 사이트로 내비게이션

> 브라우저 프로세스는 동일한 단계를 거쳐 다른 사이트로 이동을 처리하기 전에 현재 렌더링된 사이트에서 beforeunload이벤트를 확인해야 한다.

- `befroeunload`이벤트는 탭을 닫거나 이동하려고 할 때 "이 사이트를 떠나시겠습니까?"라는 경고창을 만들 수 있다.
- JS코드를 포함해 탭 안의 모든 것은 렌더러 프로세스에 의해 처리되므로 브라우저 프로세스는 새로운 내비게이션 요청이 들어오면 현재 렌더러 프로세스를 확인해야 한다.

- 렌더러 프로세스에서 내비게이션이 시작되면 렌더러 프로세스는 먼저 `beforeunload`이벤트 핸들러를 확인한다.

  - 이후에는 브라우저 프로세스가 내비게이션을 시작했을때와 동일한 과정을 거침
  - ex:) 링크를 클릭하거나 클라이언트 사이드 JS에서 `window.location'코드를 실행하는것들

- 현재 렌더링된 사이트와 다른 사이트로 이동하는 새로운 내비게이션이 발생하면 별도의 렌더러 프로세스가 새로운 내비게이션을 처리한다.
  - 현재 렌더링된 사이트를 처리한 렌더러 프로세스는 unload와 같은 이벤트를 처리하기 위해 유지된다.

### 서비스 워커

> 애플리케이션의 코드에 네트워크 프락시를 작성할수 있는 수단

- 서비스 워커를 통해 웹 개발자는 무엇을 로컬 캐시에 저장할지, 언제 네트워크에서 새 데이터를 가져올지 제어할 수 있다.
- 서비스워커가 캐시에서 페이지를 로드하도록 설정되었다면 네트워크에서 데이터를 가져오도록 요청할 필요가 없다.
- **서비스워커는 렌더러 프로세스에서 실행되는 JavaScript 코드**

#### 내비게이션 프리로드

> 내비게이션 프리로드는 서비스 워커의 시작과 병렬로 리소스를 로딩해 내비게이션 과정의 속도를 높이는 매커니즘

- 이 요청은 헤더에 표시되어 서버가 이러한 요청에 대해 다른 콘텐츠를 보낼수 있게 한다.

- ex:) 전체문서를 보내지 않고 업데이트된 데이터만 보낼수 있다.
