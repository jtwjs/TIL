## Compositor

### 브라우저 관점에서 입력 이벤트

> 화면 터치와 같은 사용자 제스처가 발생했을 때 가장 먼저 제스처를 수신하는 것은 브라우저 프로세스이다.

- 브라우저 프로세스는 제스처가 어디에서 발생했는지만 알고 있다.
  - 탭 내부의 콘텐츠는 렌더러 프로세스가 처리해야 한다.
  - 그래서 브라우저 프로세스는 이벤트 유형과 이벤트가 발생한 좌표를 렌더러 프로세스에게 보낸다.
  - 렌더러 프로세스는 이벤트 대상을 찾고 해당 대상과 연결된 이벤트 리스너를 실행해 이벤트를 적절하게 처리한다.

### 컴포지터는 입력 이벤트를 받는다.

> 웹페이지에 이벤트 리스너가 연결되어 있지 않으면 컴포지터 스레드는 메인 스레드와 상관없이 새로운 합성 프레임을 만들 수 있다.

### 고속 스크롤 불가 영역의 이해

> JS실행은 메인스레드의 작업이므로 웹 페이지가 합성될 때 컴포지터 스레드는 이벤트 핸들러가 연결된 영역을 `고속 스크롤 불가 영역`이라고 표시한다.

- 웹페이지의 이영역에서 이벤트가 발생했을 떄 컴포지터 스레드가 입력 이벤트를 메인 스레드로 보내야 하는지를 이 정보로 확인할 수 있다.
- 입력 이벤트가 고속 스크롤 불가 영역 박에서 발생했다면 컴포지터 스레드는 메인 스레드를 기다리지 않고 새 프레임을 합성한다.
- 컴포지터 스레드가 메인 스레드를 기다리지 않을 수 있는 이유는 컴포지터 스레드가 메인 스레드의 레이어 트리를 복사해서 별도로 가지고 있기 떄문

### 이벤트 핸들러를 작성할 때 주의한다.

> 웹개발에서 이벤트를 처리하는 흔한 패턴은 이벤트 위임이다.

- 이베늩 버블링 떄문에 하나의 이벤트 핸들러를 최상위 요소에 연결하고 이벤트 대상을 고려해 처리를 위임할 수 있다.
- 브라우저 관점에서 이 코드를 보면 이제 웹페이지의 모든 영역이 고속 스크롤 불가 영역으로 표시된다.
  - 즉, 애플리케이션이 신경 쓰지 않는 부분에 입력이 들어와도 컴포지터 스레드는 입력이벤트가 들어올때마다 메인스레드와 통신해야하고 메인스레드가 일을 끝내기를 기다려야 한다.
  - 그럼 컴포지터가 스크롤을 부드럽게 할수없게 된다.
- 이런 문제를 방지하기 위해 이벤트 리스너에서 `passive: true`옵션을 전달할수 있다.
  - 이 옵션은 여전히 메인 스레드에서 이벤트를 받지만, 컴포지터가 메인 스레드의 처리를 기다리지 않고 새 프레임을 만들어도 된다는 힌트를 브라우저에 주는 옵션이다.

### 이벤트 대상찾기

> 컴포지터 스레드가 입력 이벤트를 메인스레드로 보낼 때 가장 먼저 하는 일은 이벤트 대상을 찾는 `히트 테스트(hit test)`이다.

- 이벤트가 발생한 좌표에 무엇이 있는지 확인하기 위해 히트 테스트는 렌더링 프로세스에서 생성된 페인트 기록의 데이터를 사용한다.
- 레이아웃 트리가 아닌 페인트 트리를 사용하는 까닭은 `clip, opacity, transform`등의 속성을 반영해야 이벤트 대상을 정확히 알수있기 떄문

### 메인스레드로 이벤트를 전송하는 것을 최소화하기

> 메인스레드 호출이 과도해지는것을 막기 위해 Chrome은 연속적인 이벤트(ex: wheel, mousewheel, mousemove, pointermove, touchmove)를 합쳐서 바로 다음번 requsetAnimationFrame() 메서드를 실행직전까지 전송(dispatch)하지 않고 기다린다.

- `keydown, keyup, mouseup, mousedown, tocusatrt, touchend`와 같은 비연속적인(discrete) 이벤트는 즉시 전달된다.

### 한 프레임 안에서 합쳐진 이벤트(intra-fram envets)를 얻으려면 getCoalescedEvents() 메서드를 사용한다.

> 대부분의 웹 애플리케이션에서는 이벤트를 합쳐서 처리해도 사용자가 만족스럽게 사용할 수 있다.

- getCoalescedEvents() 메서드를 사용하면 합쳐진 이벤트에 대한 정보를 얻을 수 있다.

- ```js
    window.addEventListener('pointermove', function(event) {
        const events = event.getCoalescedEvents();
        for(let event of events) {
            const x = event.pageX;
            const y = event.pageY;
            // draw a line using x and y coordinates.
        }
    }
  ```
