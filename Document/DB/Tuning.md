## 튜닝(Tuning)
> 데이터베이스 튜닝이란 데이터베이스 응용 프로그램, 데이터베이스 자체, 운영체제 등의 조정을 통하여 **DBMS의 성능을 향상시키는 작업**
- 데이터베이스 튜닝을 통해 DBMS가 **높은 작업 처리량**과 **짧은 응답 시간**을 갖도록 하는 것이 중요

### 튜닝의 목표
- 데이터베이스에 접근하는 **SQL문의 실행 시 디스크 블록에 대한 접근 횟수를 최소화**한다.
    - 원하는 데이터가 포함된 디스크를 적절히 분산시켜 디스크 입·출력이 집중되는 것을 막는다.
- 디스크 블록에서 한번 읽어온 데이터는 가능한 **한 메모리 영역에 보관**하여 다시 그 데이터가 필요할 때 **메모리에서 신속히 가져오게 한다**.
    - 데이터를 디스크로부터 메모리로 로드하여 가져오는것에 비해 메모리에서 데이터를 직접 읽어오는 것이 훨씬 빠르기에<br> 캐시(Cashe) 용량을 충분히 확보한다.
- 모든 SQL문은 공유가 가능하도록 대·소문자 일치 등의 **이름 작성 규칙을 준수하여 작성**한다.
- 여러 명의 사용자가 자원들을 안정적으로 접근할 수 있도록 허용하기 위해 **잠금 기능의 사용을 최소화** 한다.
    - 잠금이 최소한으로 발생하도록 트랜잭션을 분산시키는 방법을 사용한다.

### 튜닝의 단계
- **비즈니스 규칙(Business Rule) 튜닝**
    - 데이터베이스 관리자(DBA)들이 직면한 성능상의 문제들은 실제로 시스템의 설계와<br> 구현에 대한 정확하지 않은 분석이나 부적절한 비즈니스 규칙으로 인해 발생된다.
    - 비즈니스 규칙은 동시에 많은 사용자들이 접속하는 현실적인 환경을 고려해야 한다.
- **데이터 설계(Data Design) 튜닝**
    - 구현된 응용 프로그램에서 필요한 데이터가 무엇인지 정확히 파악해야 한다.
    - 데이터 간의 관계와 속성을 명확히 파악 후 정보의 구조화 작업을 수행하는 것이 필요
- **응용 프로그램 설계(Application Design) 튜닝**
    - 같은 시스템에 접근하는 응용 프로그램이라도 구현 목적에 따라 서로 다른 설계가 가능하다.
    - 각 프로세스의 성능을 조사하여 부하가 발생하는 시점에서 해당 응용 프로그램에 실행에 필요한 시간 및 데이터들을 조사한다.
    - 튜닝을 필요로 하는 대상 응용 프로그램을 선정하고, 선정된 응용 프로그램을 위주로 집중적인 튜닝을 수행한다.
- **데이터베이스의 논리적 구조(Logical Structure) 튜닝**
    - 작업 부하가 예상되는 질의와 갱신을 고려하여 스키마를 작성함으로써 <br>DBMS의 성능을 향상시키기 위한 효율적인 데이터베이스의 논리적 구조를 생성한다. 
- **데이터베이스 접근 방식(Access Method) 튜닝**
    - SQL의 장점과 응용프로그램의 작업 처리를 최대화시키기 위해 보유하고 있는 DBMS의 기능을 충분히 활용하도록 한다.
- **접근 경로(Access Path) 튜닝**
    - 효과적인 데이터 접근을 위하여 B-트리 인덱스, 비트맵 인덱스, 역방향 인덱스 등의 사용을 고려한다.
    - 응용 프로그램 테스트 단계를 거치면서 원하는 응답 속도를 얻기 위해 인덱스의 추가 및 삭제는 물론 설계의 개선도 고려되어야 함
- **메모리 관리(Memory Management) 튜닝**
    - 성능 개선에 긍정적인 효과를 가져올 수 있도록 메모리 자원을 효율적으로 할당하여<br> 캐시의 성능을 개선하고 SQL문의 파싱 작업을 감소시켜야 한다.
- **물리적 구조(Physical Structure) 및 입·출력(Input/Output) 튜닝**
    - 접근 비용을 최소화하기 위해 효율적인 데이터 블록 운영을 고려해야 한다.
    - 디스크 입·출력 성능은 응용프로그램들의 성능을 저하시키는 주된 원인이되므로 디스크 간에 데이터를 분산하여 입·출력 경합을 감소시킨다.
- **자원의 경합(Competition) 튜닝**
    - 다수의 사용자가 동일한 자원에 대해 동시 접근을 원하는 운영 환경에서 자원에 대한 경합의 유발은 불가피하지만<br> 블록, 공유 풀, 잠금 등의 경합형태를 감소시키기 위한 노력을 계쏙 수행하여야 한다.
        - 공유 풀: 사용자가 실행한 SQL문의 구문 분석 정보가 저장되는 영역
- **H/W 시스템에 특화된 부분의 튜닝**
    - 데이터베이스는 사용되는 H/W 시스템의 종류와 특성에 따라 성능의 차이가 나타난다.
        - 사용 목적과 환경에 따라 다양한 종류와 특성을 가질수 있다는 특성
### 인덱스 튜닝
- **인덱스 종류**
    - B-트리 인덱스
        - 데이터 양에 상관없이 모든 데이터의 인덱스 탐색 시간이 동일
    - 비트맵 인덱스
        - 인덱스 컬럼의 데이터를 Bit 값인 0 또는 1 로 변환하여 인덱스 키로 사용하는 방법
        - 분포도가 좋은 컬럼에 적합하며, 효율적인 논리연산이 가능하고 저장공간이 적다.
    - 역방향 인덱스
        - 인덱스 컬럼의 데이터를 역으로 변환하여 인덱스 키로 사용하는 방법
        - B-트리 인덱스에서 발생할수 있는 불균형 문제를 해결
            - 인덱스 검색시 검색 경로가 한쪽 방향으로만 계속해서 수행되는 경우
        - 데이터의 분포도가 좋아져 검색 성능이 좋다.
    - **클러스터드 인덱스(Clustered Index)**
        - 인덱스 **키의 순서에 따라 데이터가 정렬되어 저장**되는 방식
        - 실제 데이터가 순서대로 저장되어 있어 **인덱스를 검색하지 않아도 원하는 데이터를 빠르게 찾을수 있다**.
        - 데이터 삽입, 삭제 발생 시 순서를 유지하기 위해 **데이터를 재정렬**해야 한다.
        - **한 개의 릴레이션에 하나의 인덱스**만 생성할 수 있다.
    - **넌클러스터드 인덱스(Non-Clustered Index)**
        - **인덱스의 키 값만 정렬**되어 있을 뿐 **실제 데이터는 정렬되지 않는 방식**
        - 클러스터드 인덱스보다 검색속도가 느리다.
        - **한 개의 릴레이션에 여러개의 인덱스**를 만들 수 있다.
- **인덱스 선정 기준**
    - 분포도가 좋은 컬럼은 단독으로 인덱스를 생성
    - 데이터의 변경이 빈번하지 않은 컬럼에 인덱스를 생성
    - 인덱스들이 자주 조합되어 사용되는 경우는 하나의 결합 인덱스를 생성한다.
        - 결합 인덱스: 한 릴레이션 내에 존재하는 여러 컬럼들을 묶어 하나의 인덱스로 만든 것
    - 결합 인덱스의 컬럼 순서는 데이터의 분포도가 나은 컬럼을 선행 컬럼으로 설정
- **인덱스를 사용하지 못하는 경우**
    - 인덱스 키 생성 시 NULL 값은 인덱스 대상에 포함되지 않으므로 **'IS NULL'과 'IS NOT NULL'을 적용하여 추출한 데이터**는 인덱스를 사용해도 의미가 없다.
    - <>, !=, NOT 등의 **부정연산자**는 다수의 데이터를 검색하므로 인덱스를 이용하지 못하고 전체 테이블을 대상으로 검색할때 사용
    - **LIKE '%A'**와 같은 경우에는 찾고자 하는 검색어의 첫 글자를 알수 없기에 정렬되어 있는 인덱스를 처음부터 검색해야 한다.
    - 인덱스 컬럼에 함수나 수식을 사용하면 인덱스 키 값이 변형되어 인덱스로 사용할 수 없게 된다.