## Index(인덱스)
>데이터베이스 테이블에 있는 데이터를 빠르게 찾기 위한 용도의 데이터베이스 객체이며 일종의 색인기술이다.<BR>데이터 레코드(튜플)에 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조이다.
- 색인이 없으면 특정한 값을 찾기 위해 모든 데이터 페이지를 다 뒤지는 **TABLE SCAN**이 발생한다
    - TABLE SCAN : 테이블에 있는 모든 레코드를 순차적으로 읽는 것으로 FULL TABLE SCAN이라고도 한다.
- 기본키를 위한 인덱스를 기본인덱스라 하고, 기본인덱스가 아닌 인덱스들을 보조 인덱스라고 한다.
- 대부분의 관계형 데이터베이스 관리 시스템에서는 모든 **기본키에 대해서 자동적으로 기본 인덱스를 생성**한다.
- **레코드의 물리적 순서가 인덱스의 엔트리 순서와 일치하게 유지되도록 구성되는 인덱스를 클러스터드(Clustered)인덱스** 라고 한다.
- 테이블에 index를 생성하게 되면 index table을 생성해 관리한다.
- 인덱스는 테이블에 있는 하나 이상의 컬럼으로 만들 수 있다.
### 인덱스 종류
- **m-원 검색 트리(m-Way Search Tree)**
    - 한 노드가 1개의 키 값과 2개의 서브 노드를 갖는 이진 검색 트리를 일반화 한 트리로서<br> **한 노드가 최대 m-1개의 키 값과 최대 m개의 서브 노드를 갖는다.**
    - 이진 검색 트리에 비해 **분기율이 향상**되므로 트리 깊이가 낮아져 **특정 노드에 대한 검색 시간이 감소**됨
        - **분기율** : 한 노드에서 서브 트리로 가는 포인터의 개수
        - 한 노드에 엔트리가 많아지면 서브 트리로 가는 경로도 많아지고 트리 높이도 낮아지게 된다.
    - **키의 삽입 및 삭제 시 트리의 균형을 유지하기위하여 복잡한 연산이 수반되어야 하는 단점**이있다.
- **B-트리 인덱스**
    - 인덱스를 구성하는 방법으로 많이 사용되는 균형된 m-원 검색트리이다.
    - 키 값과 레코드를 가리키는 포인터들이 트리 노드에 오름차순으로 저장된다.
    - 키의 삽입과 삭제 시 노드의 분열과 합병 발생 가능
    - 인덱스 키(인덱스로 만들 테이블의 컬럼 값)와 이 키에 해당하는 칼럼 값을 가진 테이블의 로우가 저장된 주소 값으로 구성됨
- **B*-트리 인덱스**
    - B-트리의 문제점인 빈번한 노드의 분할을 불이는 목적으로 제시된 B-트리의 변형이다.
    - B*-트리에서는 각 노드가 가능한 한 최소 3/2가 채워지도록 한 것이 특징 
- **B+-트리**
    - B-트리의 변형으로 단말 노드가 아닌 노드로 구성된 **인덱스 세트**와 단말 노드로만 구성된 **순차 세트**로 구분된다.
    - 인덱스 세트: **단말 노드에 있는 키값을 찾아갈 수 있는 경로**로만 제공
    - 순차 세트: 순차세트에있는 단말노드가 해당 **데이터 레코드의 주소**를 가리킨다 
    - 인덱스 세트에 있는 모든 키값이 단말 노드에 다시 나타나므로 단말 노드만을 이용한 순차처리가 가능
    - B+-트리에서의 **직접 접근에는 인덱스세트**가 사용, **순차 접근에는 순차세트**가 사용됨
- **자동 인덱스**
    - **PRIMARY KEY** 또는 **UNIQUE** 제한 규칙에 의해 **자동적으로 생성**되는 인덱스
- **수동 인덱스**
    - **CREATE INDEX** 명령을 실행해서 만드는 인덱스
### 인덱스를 사용하는 이유
- **빠른 검색**을 위해서 인덱스 사용
- **인덱스의 장점**
    - 검색속도가 빨라짐
    - 시스템에 걸리는 부하가 줄어 시스템 전체 성능을 향상시킴
- **인덱스의 단점**
    - 인덱스를 위한 추가적인 공간이 필요
    - 인덱스를 생성하는데 시간이 걸림
    - 데이터의 변경작업이 자주 일어날 경우에는 오히려 성능이 저하된다.
### 인덱스를 사용해야 하는 경우
1. 테이블의 행의 수가 많을때
2. WHERE 문에 해당 컬럼이 많이 사용될 때
3. JOIN에 자주 사용되는 칼럼
4. NULL을 포함하는 컬럼이 많은 경우
### 인덱스를 불필요한 경우
1. 테이블에 행의수가 적을때
2. 테이블에 DML 작업이 많은 경우


### 인덱스 생성
- **표기형식**
    ```sql
    CREATE INDEX [인덱스명] ON [테이블명](칼럼1,칼럼2,···)
    ```

### 인덱스 조회
- **표기형식**
   ```SQL
    SELECT * FROM USER_INDEXES WHERE TABLE_NAME = '테이블명';
    ```

    ```SQL
    SELECT INDEX_NAME,TABLE_NAME,COLUMN_NAME
    FROM USER_IND_COLUMNS
    WHERE TABLE_NAME IN('테이블명');
    ```
    
### 인덱스 삭제
> 인덱스의 구조는 테이블과 독립적이므로 인덱스의 삭제는 테이블의 데이터에는 아무런 영향없다.<BR>인덱스를 삭제하려면 인덱스의 소유자 이거나 DROP ANY INDEX 권한을 가지고 있어야한다.
- 인덱스는 조회성능을 극대화하기 위해 만든 객체인데 너무 많이 만들면<BR> INSERT,DELETE,UPDATE시에 부하가 발생해 전체적인 데이트베이스 성능을 저하한다. 
- **표기형식**
    ``` DROP INDEX [인덱스명] ```

### 인덱스(Index) 리빌드(Rebuild)사용 예시
>생성된 인덱스는 트리구조를 가진다. 삽입,수정,삭제등이 오랫동안 일어나다보면<br> 트리의 한쪽이 무거워져 전체적으로 트리의 깊이가 깊어진다. <br>이러한 현상으로 인해 인덱스의 검색속도가 떨어지므로 주기적으로 리빌딩 작업을 하는것이 좋다.

- **인덱스 리빌드 할 대상 조회쿼리**
>INDEX 트리의 깊이가 4이상인 INDEX를 조회하는 쿼리 (여기에 검색되는 INDEX는 리빌딩하는 것이 좋음)

```SQL
SELECT TABLESPACE_NAME, TABLE_NAME, INDEX_NAME, BLEVEL,
        DECODE(SIGN(NVL(BLEVEL,99)-3),1,DECODE(NVL(BLEVEL,99),99,'?','Rebuild'),'Check')CNF
FROM USER_INDEXES
WHERE BLEVEL > 4
ORDER BY BLEVEL DESC
```
- **인덱스 리빌드**
    - **표기형식** :
    ```SQL
    ALTER INDEX [인덱스명] REBUILD;
    ```
- **전체 인덱스 리빌드 쿼리문 만들기**
> 일일히 리빌드 시키기 귀찮으면 USER_INDEXES에 있는 인덱스를 조회하여 한번에 만들어실행

- **표기형식**
    ```SQL
    SELECT 'ALTER INDEX' ||INDEX_NAME||'REBUILD;' 
    FROM USER_INDEXES;
    ```

### 인덱스(Index)를 남발하지 말아야 하는 이유
>개발을 진행할때에 대개 개발서버와 운영서버를 나누어서 관리합니다. <BR>대부분 개발서버에서 개발을 할때에는 적은량의 데이터를 가지고 로직검사를 하며<BR> 로직검사에 통과한 코드들이 운영서버에 업데이트가 되죠. 하지만 개발서버에는 <BR>잘 동작하던 로직들이 운영서버의 많은량의 데이터들을 처리하다보면 성능이슈가 많이 발생합니다.<BR> 그 성능이슈의 주요원인은 바로 데이터베이스에 있습니다.<BR> 데이터베이스 관리자는 **성능문제가 발생하면 가장 빨리 생각하는 해결책이 인덱스 추가 생성**입니다.<BR> 그렇게 하여 인덱스를 하나 만들었다고 합시다. 그리고 또 다른 SQL에서문에서 성능이슈가 발생하여 또 인덱스를 만들었다고 합시다.<BR> 이렇게 **문제가 발생할때마다 인덱스를 생성**하면서 인덱스가 쌓여가는것은 결코 좋지않습니다. <BR>인덱스를 만드는것은 하나의 쿼리문을 빠르게는 만들 수 있지만 **전체적인 데이터베이스의 성능 부하를 초래**합니다. <BR>그렇기에 인덱스를 생성하는것 보다는 **SQL문을 좀 더 효율적으로 짜는 방향으로 나가야합니다**.<BR> **인덱스 생성은 꼭 마지막 수단**으로 강구해야 할 문제입니다.