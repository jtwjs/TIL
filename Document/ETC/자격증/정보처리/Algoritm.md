## 기본알고리즘

### 선택정렬
> n번째 자료를 n+1번째 자료부터 마지막 자료까지 차레대로 비교하여 가장 작은 값을 찾아 정렬
- 순서도
    - 1 n-1 , i+1 n
### n과 가까운수 구하기
> n과 정렬된 숫자 두 수의 차에 최소값을 구하는 것
- 최소값의 초기 값으로 1자리 수에서 나올수 있는 가장 큰값(=9)로 치환한다.
- 음수가 나오면 안되므로 두수를 대소 비교후 큰값에서 작은 값을 빼야한다.
- 두 수 의 차에 최소값과 가지고있는 최소값을 대소 비교 후 더 작은값으로 치환
- 근사값에 비교한 숫자를 집어 넣는다.
- 정렬된 숫자 길이 만큼 반복 

### 삽입정렬
> 두번쨰 자료부터 시작하여 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 <br>자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬
- 순서도 (i= 정렬 회전 수, K= 비교 대상이 있는 위치를 지정해주는 변수)
    - i = 2,n,1 (2부터 n까지 1씩 증가)
        - KEY = A[i] : 비교 기준 값을 KEY에 치환
        - K = i-1,1,-1 (i-1부터 1까지 -1씩 증가)
            - A[K] > KEY : 비교값과 KEY값 비교
                - 거짓일시 반복문을 빠져나옴(그 이하는 이미 정렬되서 볼필요없이 작기때문)
            - A[k+1] = A[K] : A[K]값이 더크면 자리바꿈
        - A[K+1] = KEY : 한회전이 끝났으므로 그 회전에서의 기준값이 들어갈 위치를 찾음

### 소인수 분해
> 어떤수 x를 2부터 차례대로 x의 제곱근까지 숫자로 나누어떨어지는지 검사
- X를 제수(2부터 시작)로 나눈다. 
- 나머지가 0이면 배열에 차례대로 저장 
    - 나머지가 0이 아니면 제수를 1씩 늘려 나눠준다.
- 몫을 X에 치환한다.
- 몫이 1일 경우 소인수 분해끝..
- NMG : B-MOK*D
    - B: 소인수로 분해할 숫자<Br>D: 제수 (2부터시 작)

### 진법변환 (10진수 -> 2진수)
>10진수를 2진수로 변환하려면 10진수를 2로 나누어 나머지를 구한후 저장 <br>다시 몫을 2로 나누어 나머지를 구해 저장하는 과정 반복<br> 몫이 0이 될떄까찌 이 작업 반복후 마지막에 구한 나머지부터 거꾸로 출력

### 진법변환 (2진수 -> 10진수)
>자릿값형태를 이용 
- 부호비트있는 경우
    - 2의보수일 때 (부호비트 1일때 S[1]=1 -> 음수)
        - DEC = 128 - DEC
        - DEC = DEC*(-1)

### 버블정렬
>인접한 두 숫자를 비교 (마지막-1)번째 자료와 마지막 자료를 비교하여 교환하면서 자료를 정렬<br> 1회전이 끝나면 맨 끝에 있는 자료는 가장 큰 수 이므로 정렬에서 제외
- 순서도
    - for ( i = 1; i < n-1; i++)
        - for( j = 1; j < n-i; j++)

### 병합정렬
> 정렬된 2개의 파일 또는 배열을 하나의 정렬된 자료로 만드는 것<br> 배열을 이용할때는 자료의 크기가 작은 쪾의 배열 첨자를 증가시키면서 2개의 배열을 1개로 합친다.<br>병합을 수행할때 병합할 두 자료의 대소를 비교하여 클때, 같을때, 작을떄를 구분하여 처리
- 배열숫자중 정렬된 숫자 0을 만나면 그배열은 숫자를 다소진했기에 나머지 배열을 병합배열에 몰빵 

### 2차원배열 (ㄹ)
>행을 나타내는 변수(i), 열을 나타내는 변수(j), 열의 시작위치(L) 열의 끝위치(M) 지정 행이 증가 할때마다 시작위치 끝위치 스왑<br> 증가값을 지정해주는 변수 (N(N) -> 1과 -1 반복

- 순서도
    - for( i = 1; i < n; i++)
        - for (j = L; j < M; N)
            - K = K + 1
            - A[i][j] = K
        - 스왑 
            - p = L
            - L = M
            - M = P
        - N = N * -1

### 수열 합계
> i = 수열의 각항을 만들기 위해 1 ~ n까지 증가시킬 변수 <br> J = 각 항이 1씩 증가할때마다 그 값을 누적하여 저장
- 순서도
    - i = 0, j = 0 ( 증가값이 2일 경우 첫 항이 1이면 초기값을 -1로 지정)
    - i = i+증가값 (수열의 각 항을 만듬, 증가값에 따라 바뀜)
    - J = J+i (수열의 각 항의 합계를 구하기 위해 누적)

- 스위치 변수 이용하는 수열
    - SW(스위치변수) 
        - SW 값(0,1)에 따라 J= J+i, J= J-i 결정
        - ```
            if( SW == 0 ){
                J = J + i;
                SW = 1;
            }
            else if (SW == 1){
                J = J - i;
                SW = 0;
            }
        ```

### 석차구하기
> 특정인의 점수에 대한 석차를 알려면 다른 사람들과 점수를 비교해보면 된다.<br> 점수를 비교하기전에 모두 석차 1등으로 설정, 다른 사람의 점수와 비교후 높은사람이 있으면 석차를 1씩 증가 <br> 이런 작업을 모든 사람에게 반복해 적용

### 숫자/입출력 알고리즘

- [영상보기](https://www.youtube.com/watch?v=oBorUeBIlm0)

### 최소값구하기


### 2차원배열 (달팽이)
> 행고정열변화 열고정행변화 반복
- 크게 2개의 반복문(1.열변환, 2.행변환)을 가지고 반복

### 2차원배열 (90도)
- Tip
    - B[j][6-i] = A[i][j]

### 2차원배열 (모래시계)
> 행의 중간값으로 나눠서 배열 반복 두개로 나눈다!
- 순서도(A(5,5)기준)
    - for(i=1; i<=M; i++){
        for(j=i; j<6-i; j++){

        }
    }
      for(i=M+1; i<=5; i++){
          for(j=6-i; j< i; j++){

          }
      }
    - 